## Copilot Instructions – BU Superagent (Strict Architecture Mode)

**Purpose:** Maintain the Clean Architecture RAG skeleton (German BU domain). Domain stays pure (no I/O, deterministic); Application orchestrates; Infrastructure adapts tech; Interface/config only wire things together.

### Architecture snapshot
- `domain/`: Pure business logic—entities, value objects, domain services. **No I/O, no env access, no infrastructure imports**. `services/chunking.py` does semantic chunking (section → paragraph → sentence → overlap merge) with tunable `ChunkingParams`. `services/ranking.py` provides deterministic algorithms: `deduplicate_by_cosine`, `mmr` (Maximal Marginal Relevance), and `passes_confidence` for confidence-gate pattern. `services/relevance_scoring.py::cosine_similarity` is intentionally `NotImplemented` (placeholder). Domain models (`models.py`): `RetrievedChunk`, `Citation`, `RankedChunk` are pure POJOs moved from application layer (SAM fix). Domain errors (`errors.py`): typed errors like `LowConfidenceError`, `ValidationError`, `EmbeddingError` enable business-meaningful failures without leaking infra details.
- `application/`: Use cases + ports (interfaces). `use_cases/ingest_documents.py::IngestDocuments.execute` is the active ingestion orchestrator (returns chunk count). `use_cases/query_knowledge_base.py::QueryKnowledgeBase.execute` orchestrates: validate → embed → search → domain ranking → confidence gate → LLM generation. Uses `Result[T, E]` type for explicit success/failure paths (no silent failures). All use cases receive dependencies via constructor (ports), never import infrastructure directly.
- `infrastructure/`: Adapters implementing ports. **Lazy imports via `importlib.import_module`** for testability—allows tests to inject fake modules via `monkeypatch`. Adapters wrap errors in domain exceptions (`RuntimeError` → `EmbeddingError`). Examples: `embeddings/sentence_transformers_adapter.py` prefixes E5 queries/passages and caches models; `vectorstore/{chroma,qdrant,faiss}_vector_store.py` implement `VectorStorePort`; `parsing/pdf_text_extractor.py` wraps pypdf.
- `interface/`: CLI/HTTP shells only. `cli/main.py` deliberately raises `NotImplementedError` if `--question` is missing (tests assert this). Keep thin: parse args → call composition builders → delegate to use cases → format output.
- `config/`: **ONLY place for env/DI/wiring**. `composition.py` provides builder functions (`build_embedding`, `build_vector_store`, `build_llm`, `build_query_use_case`) that read `settings.py::AppSettings` and wire concrete adapters. `_build_vector_store` respects `VECTOR_BACKEND` (`qdrant`|`chroma`|`faiss`) and falls back to FAISS for unknown values.

### Core contracts & behaviors
- **Vector store port** (`application/ports/vector_store_port.py`) requires strict call sequence: `ensure_collection` → `upsert` → `search`. Tests in `tests/infrastructure/test_vectorstore_adapters_fake.py` assert this ordering—**always call `ensure_collection` before persisting**. Adapters return `RetrievedChunk` with `vector=None` by default (saves bandwidth; domain model supports vectors for MMR/diversity).
- **Embedding port** (`application/ports/embedding_port.py`) supports kinds `"mxbai"|"jina"|"e5"`. The Sentence Transformers adapter (`embeddings/sentence_transformers_adapter.py`) prefixes E5 queries ("query: {text}") and passages ("passage: {text}") automatically via `_prefix_e5_query/_passage` helpers. Models are cached per name. **All embeddings are L2-normalized** before returning.
- **Document loading** uses `DocumentLoaderPort.load` returning `DocumentPayload`. `PlainTextLoaderAdapter` trims UTF-8 files; `PDFTextExtractorAdapter` wraps pypdf. Both raise `RuntimeError` on failure (adapters wrap as `DocumentError`).
- **Ingestion pipeline** (`IngestDocuments.execute`): load → chunk via domain service (`chunk_text_semantic`) → embed texts → `ensure_collection` + `upsert` with payloads carrying `doc_id`, `chunk_index`, `section_title`, source metadata. Returns total chunk count.
- **Query pipeline** (`QueryKnowledgeBase.execute`): validate → embed query → vector search → deduplicate (`deduplicate_by_cosine`) → optional MMR (`mmr` for diversity) → confidence gate (`passes_confidence`) → LLM generation if above threshold, else return `LowConfidenceError` with context. Uses `Result[RAGAnswer, DomainError]` type.

### Infrastructure adapters & wiring
- **Vector backend selection**: `build_vector_store` in `config/composition.py` honours `VECTOR_BACKEND` env var (`qdrant` | `chroma` | `faiss`, default `chroma`). **Unknown values fall back to FAISS** for testability. Qdrant adapter recreates collection with cosine distance each time; Chroma persists under `var/chroma/...`; FAISS holds in-memory `IndexFlatIP`.
- **Lazy imports pattern**: All infrastructure adapters use `importlib.import_module` instead of direct imports (e.g., `chromadb = import_module("chromadb")`). This enables test isolation via `monkeypatch.setitem(sys.modules, "chromadb", FakeModule())`. See `tests/infrastructure/test_vectorstore_adapters_fake.py` for examples.
- **Embedding device config**: `build_embedding` in `composition.py` reads `EMBEDDING_DEVICE` env var (default `cpu`). Production may use `cuda`; adjust settings before adapter instantiation. Sentence Transformers adapter caches models by name in `_model_cache`.
- **LLM adapter**: `VLLMOpenAIAdapter` wraps OpenAI-compatible API (vLLM, Ollama, etc.). Reads `LLM_BASE_URL`, `LLM_API_KEY`, `LLM_MODEL` from settings. Default points to local vLLM server (`http://localhost:8000/v1`).
- **Reranker stub**: `infrastructure/reranking/cross_encoder.py` implements `RerankerPort` but is not wired into composition yet—keep pure and self-contained when extending.

### Developer workflow (Windows cmd examples)
- Create venv + install dev deps: `python -m venv .venv` → `.venv\Scripts\pip.exe install -e ".[dev]"`.
- Lint/format: run `lint.cmd` (Ruff configured for lint + style) or `.venv\Scripts\python.exe -m ruff .` as needed.
- Types & layering: `.venv\Scripts\python.exe -m mypy` and `.venv\Scripts\lint-imports.exe --config importlinter.ini` keep import boundaries intact.
- Tests: `.venv\Scripts\python.exe -m pytest -q`. Active suites cover domain chunking (`tests/domain/test_chunking.py`), ingestion flow (`tests/application/test_ingest_use_case_v2.py`), CLI placeholders, and infra adapter fakes. Leave NotImplemented sentinels in place where asserted.

### Guardrails & examples
- **File management**: Do not remove/rename files without checking Port relations. If a file is an unused duplicate adapter, remove it. Utilities belong under `infrastructure/<tech>/utils.py` and are only imported by adapters.
- **Layering enforcement**: `importlinter.ini` defines strict contracts. Application can import domain; infrastructure/interface are independent; interface CANNOT import domain directly (only via application). Run `.venv\Scripts\lint-imports.exe --config importlinter.ini` to validate. Never import infrastructure from domain/application.
- **NotImplemented sentinels**: `domain/services/relevance_scoring.py::cosine_similarity` deliberately raises `NotImplemented` (placeholder); `cli/main.py` raises `NotImplementedError` when `--question` is missing (test assertion). **Do not remove these—tests rely on them**.
- **Result type pattern**: Use cases return `Result[T, E]` with explicit `Result.success(value)` or `Result.failure(error)` paths. Check `result.ok` before accessing `result.value`. No silent failures or uncaught exceptions in business logic.
- **Domain chunking**: `chunk_text_semantic` in `domain/services/chunking.py` is deterministic. Follow tests in `tests/domain/test_chunking.py` when modifying—maintain overlap/tail semantics and section-aware merging.
- **Adapter patterns**: New adapters must (1) use `import_module` for lazy imports, (2) wrap errors in domain exceptions (e.g., `RuntimeError` → `EmbeddingError`), (3) add contract tests under `tests/infrastructure/` with fake modules. See `test_vectorstore_adapters_fake.py` for reference.
- **Interface shells**: Keep `interface/cli/` and `interface/http/` thin. Parse inputs → call composition builders (`build_query_use_case`, etc.) → format outputs. No business logic here.
